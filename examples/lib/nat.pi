#attach: bool.pi
#attach: stack.pi

#global: 0
#global: 1
#global: add
#global: read_unary
#global: write_unary

! Numbers have a counter interface with a step channel and a zero channel which
! will return ff or tt (if it is the last step).
c<<0; +step,zero->c; <-step;tt->zero.
c<<1; +step,zero->c; <-step;ff->zero; <-step;tt->zero.

! Addition of two encoded numbers.
x,y,ret<<<add; +n->ret;
c<<n; sx,zx<-<x; sy,zy<-<y; ,next,stage<-<bool; +step,zero->c;
<<step; +use_x,use_y;(
  use_x,use_y>->stage.
  <-use_x; ->sx; is_zero<-zx; +t,f;(
    t,f>->is_zero.
    <-t; <>next; ->step.
    <-f; ff->zero.
  )
  <-use_y; ->sy; is_zero<-zy; +t,f;(
    t,f>->is_zero.
    <-t; tt->zero.
    <-f; ff->zero.
  )
)

! Unary IO for natural numbers: 0, 10, 110, 1110, ..., 1^n0

! Read unary number from stdin.
c<<read_unary; push,pop<-<stack; +ack; 0,ack>->push; <-ack;(
  ->stdin_read.
  <-stdin__0; empty,n<-<pop; n->c.
  <<stdin__1; empty,n<-<pop; +next;(
    ,next>->empty.
    <-next;
      +ret; n,1,ret>->add; m<-ret;
      +ack; m,ack>->push; <-ack;
      ->stdin_read.
  )
)

! Write unary number to stdout.
n<<write_unary; step,zero<-<n; ->step;
  is_zero<<zero; +t,f;(
    t,f>->is_zero.
    <-t; ->stdout__0;<-stdout_write; ->stdout_0A.
    <-f; ->stdout__1;<-stdout_write; ->step.
  )