#attach: bool.pi
#attach: stack.pi

#global: 0
#global: 1
#global: add
#global: read_unary
#global: write_unary

! Numbers have a counter interface with a step channel and a zero channel which
! will return ff or tt (if it is the last step).
c<<0; +step,zero; step,zero->c; <-step;tt->zero.
c<<1; +step,zero; step,zero->c; <-step;ff->zero; <-step;tt->zero.

! Addition of two encoded numbers.
xy<<add;->xy; x,y<-xy; ,next,stage<-<bool; +n;n->xy;
  c<<n; sx,zx<-<x; sy,zy<-<y; +step,zero; step,zero->c;
    <<step; +use_x,use_y;(
      use_x,use_y>->stage.
      <-use_x; ->sx; is_zero<-zx; +t,f;(
        t,f>->is_zero.
        <-t; <>next; ->step.
        <-f; ff->zero.
      )
      <-use_y; ->sy; is_zero<-zy; +t,f;(
        t,f>->is_zero.
        <-t; tt->zero.
        <-f; ff->zero.
      )
    )

! Unary IO for natural numbers: 0, 10, 110, 1110, ..., 1^n0

! Read unary number from stdin.
r<<read_unary; push,pop<-<stack; <-[0>->push];(
  ->stdin_read.
  <-stdin__0; empty,n<-<pop; n->r.
  <<stdin__1; empty,n<-<pop; +next;(
    ,next>->empty.
    <-next; m<-[n,1>->add]; <-[m>->push]; ->stdin_read.
  )
)

! Write unary number to stdout.
n<<write_unary; step,zero<-<n; ->step;
  is_zero<<zero; +t,f;(
    t,f>->is_zero.
    <-t; ->stdout__0;<-stdout_write; ->stdout_0A.
    <-f; ->stdout__1;<-stdout_write; ->step.
  )