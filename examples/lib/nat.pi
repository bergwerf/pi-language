#attach: bool.pi
#attach: stack.pi

#global: 0
#global: 1
#global: add
#global: mul
#global: read_unary
#global: write_unary

! Numbers have a counter interface with a step channel and a zero channel which
! will return ff or tt (if it is the last step).
c<<0; +step,zero->c; <-step;tt->zero.
c<<1; +step,zero->c; <-step;ff->zero; <-step;tt->zero.

! Addition of two encoded numbers.
n,m,ret<<<add; +k->ret;
c<<k; ns,nz<-<n; ms,mz<-<m; ,next,stage<-<bool; +step,zero->c;
<<step; +use_n,use_m;(
  use_n,use_m>->stage.
  <-use_n; ->ns; is_zero<-nz; +t,f;(
    t,f>->is_zero.
    <-t; <>next; ->step.
    <-f; ff->zero.
  )
  <-use_m; ->ms; is_zero<-mz; +t,f;(
    t,f>->is_zero.
    <-t; tt->zero.
    <-f; ff->zero.
  )
)

! Multiplication of two encoded numbers.
n,m,ret<<<mul; get,set<-<cell; +ack; 0,ack>->set; <-ack; ns,nz<-<n; +loop;(
  ->loop.
  <<loop; acc<-<get; ->ns; is_zero<-nz; +return,add_m;(
    return,add_m>->is_zero.
    <-return; acc->ret.
    <-add_m;
      +ret; acc,m,ret>->add; acc<-ret;
      +ack; acc,ack>->set; <-ack;
      ->loop.
  )
)

! Unary IO for natural numbers: 0, 10, 110, 1110, ..., 1^n0

! Read unary number from stdin.
c<<read_unary; push,pop<-<stack; +ack; 0,ack>->push; <-ack;(
  ->stdin_read.
  <-stdin__0; empty,n<-<pop; n->c.
  <<stdin__1; empty,n<-<pop; +next;(
    ,next>->empty.
    <-next;
      +ret; n,1,ret>->add; m<-ret;
      +ack; m,ack>->push; <-ack;
      ->stdin_read.
  )
)

! Write unary number to stdout.
n<<write_unary; step,zero<-<n; ->step;
  is_zero<<zero; +t,f;(
    t,f>->is_zero.
    <-t; ->stdout__0;<-stdout_write; ->stdout_0A.
    <-f; ->stdout__1;<-stdout_write; ->step.
  )